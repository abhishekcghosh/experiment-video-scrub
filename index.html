<!DOCTYPE html>
<html>
    <head>
        <title>Video Scrubbing Trials</title>
        <meta charset="utf-8" />
        <meta name="description" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="common/main.css" />
    </head>
    <body>
        <div id="content">
            <h1>
                Video Scrubbing Trials
            </h1>
            <p>
                Check out the
                <a href="https://github.com/abhishekcghosh/experiment-video-scrub" target="_blank">source</a> and
                <a href="https://github.com/abhishekcghosh/experiment-video-scrub/blob/master/README.md" target="_blank"
                    >README</a
                >
                for more details.
            </p>
            <h3>
                Demos:
            </h3>
            <ul class="index-list">
                <li>
                    <a href="video-current-time">video-current-time</a>
                    <p>
                        This mechanism simply loads the video in a HTML5 video tag and attempts to set the currentTime
                        property of the loaded video in an attempt to scrub it when scrolling. This somewhat works out
                        on high end devices especially with low quality videos. But can't be trusted, atleast definitely
                        not on mobile browsers. Rule of thumb, the browser does a lot of intelligent things to adjust
                        the how and when of video seeking and painting the corresponding frame. This is probably the
                        most naive (and stupidest) way.
                    </p>
                </li>
                <li>
                    <a href="video-play-unpack-frames-canvas">video-play-unpack-frames-canvas</a>
                    <p>
                        This mechanism simply downloads the video in an in-memory HTML5 video tag, and unpacks video
                        frames from it by starting to play the video and then listening to regular timeupdate event on
                        the video element to be fired, at which point it pauses the video to grab a frame by painting
                        the outcome on an OffscreenCanvas element and collecting the canvas' 2D context imageData
                        (pixels that represent the frame). When done, it plays the video again, and the loop continues
                        till the video has been played to the end. Imagine this to be generating a set of image files
                        from the original source video we we do this generation in the browser directly using an
                        OffscreenCanvas. We could do this with a normal canvas element as well, but not a great reason
                        to do that. Once that is done, for scrubbing, we figure out the correct frame to paint based on
                        the input signal (scroll position in this example) and then paint the correct frame on a visible
                        canvas element's 2D context on the page. This is not as elegant as we may initially think. Of
                        course, the time to extract out the frames is lower-bound by the duration of the video but
                        overall it takes much more time due to so much amount of javascript work happening.
                    </p>
                </li>
                <li>
                    <a href="video-seek-unpack-frames-canvas">video-seek-unpack-frames-canvas</a>
                    <p>
                        Very similar to canvas-play-unpack-frames above, this also downloads the video in an in-memory
                        HTML5 video tag, but unpacks video frames from it by seeking through the video at regular
                        intervals and painting the outcome on a OffscreenCanvas element and collecting the canvas' 2D
                        context imageData (pixels that represent the frame). A predefined number of frames are unpacked.
                        Once that is done, for scrubbing, we figure out the correct frame to paint based on the input
                        signal (scroll position in this example) and then paint the correct frame on a visible canvas
                        element's 2D context on the page. Thus, it brings some improvements over
                        canvas-play-unpack-frames - much faster due to seek rather than play (not being bound to video
                        duration), and with a bit more control on the number of frames and perhaps hopefully cheaper in
                        comparison.
                    </p>
                </li>
            </ul>
        </div>
    </body>
</html>
