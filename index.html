<!DOCTYPE html>
<html>
    <head>
        <title>Video Scrubbing Trials</title>
        <meta charset="utf-8" />
        <meta name="description" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="common/main.css" />
        <link
            rel="preload"
            href="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4"
            as="video"
        />
    </head>
    <body>
        <div>
            <h1>
                Video Scrubbing Trials
            </h1>

            <p>
                Check out the
                <a href="https://github.com/abhishekcghosh/experiment-video-scrub" target="_blank">source</a>
                for more details.
            </p>

            <h3>
                Attempts &amp; Demos
            </h3>

            <h4>
                <a href="/video-current-time">#1: video-current-time</a>
            </h4>
            <p>
                This mechanism simply loads the video in a HTML5 <code>video</code> tag and attempts to set the
                <code>currentTime</code>
                property of the loaded video in an attempt to scrub it when scrolling.
            </p>
            <p>
                This somewhat works out on high end devices especially with low quality videos. But can’t be trusted,
                atleast definitely not on mobile browsers. Rule of thumb, the browser does a lot of intelligent things
                to adjust the how and when of video seeking and painting the corresponding frame. This is probably the
                most naive (and stupidest) way.
            </p>

            <h4>
                <a href="/video-play-unpack-frames-canvas">#2: video-play-unpack-frames-canvas</a>
            </h4>
            <p>
                This mechanism simply downloads the video in an HTML5 <code>video</code> tag, and unpacks video frames
                from it by starting to <code>play</code> the video and then listening to regular
                <code>timeupdate</code> event on the video element to be fired, at which point it
                <code>pauses</code> the video to grab a frame by painting the outcome on an
                <code>OffscreenCanvas</code> element and collecting the frame’s image bitmap from canvas’ 2D context.
                When done, it <code>plays</code> the video again, and the loop continues till the video has been played
                to the end.
            </p>
            <p>
                Imagine this to be generating a set of image files from the original source video we we do this
                generation in the browser directly using an <code>OffscreenCanvas</code>. We could do this with a normal
                <code>canvas</code>
                element as well, but not a great reason to do that.
            </p>
            <p>
                Once that is done, for scrubbing, we figure out the correct frame to paint based on the input signal
                (scroll position in this example) and then draw the correct frame on a <em>visible</em>
                <code>canvas</code> element’s 2D context on the page.
            </p>
            <p>
                This is not as elegant as we may initially think. Of course, the time to extract out the frames is
                lower-bound by the duration of the video but overall it takes much more time due to so much amount of
                javascript work happening.
            </p>

            <h4>
                <a href="/video-seek-unpack-frames-canvas">#3: video-seek-unpack-frames-canvas</a>
            </h4>
            <p>
                Very similar to <code>video-play-unpack-frames-canvas</code>, this also downloads the video in an HTML5
                <code>video</code>
                tag, but unpacks video frames from it by <em>seeking</em> through the video at regular intervals and
                painting the outcome on a <code>OffscreenCanvas</code> element and collecting the frame’s image bitmap
                from canvas’ 2D context. A predefined number of frames are unpacked.
            </p>
            <p>
                Once that is done, for scrubbing, we figure out the correct frame to paint based on the input signal
                (scroll position in this example) and then draw the correct frame on a <em>visible</em>
                <code>canvas</code> element’s 2D context on the page.
            </p>
            <p>
                Thus, it brings some improvements over <code>video-play-unpack-frames-canvas</code> - much faster due to
                seek rather than play (not being bound to video <code>duration</code>), and with a bit more control on
                the number of frames and perhaps hopefully cheaper in comparison.
            </p>

            <h4>
                <a href="/video-seek-media-stream-image-capture">#4: video-seek-media-stream-image-capture</a>
            </h4>
            <p>
                Largely similar to above approach of <code>video-seek-unpack-frames-canvas</code> in terms of seeking
                through the video using a HTML5 <code>video</code> tag, but instead of pausing and drawing it on a
                canvas context to extract out the frame’s image bitmap data, we use
                <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/captureStream"
                    ><code>captureStream()</code></a
                >
                on the <code>video</code> element to capture the video stream and then we use the captured stream’s
                <a href="https://developer.mozilla.org/en-US/docs/Web/API/ImageCapture"><code>ImageCapture</code></a>
                interface to grab the image bitmap data of a frame at a desired point in time.
            </p>
            <p>
                Once that is done, for scrubbing, we follow the exact same approach as above.
            </p>
            <p>
                While this approach originally seemed relatively a bit elegant conceptually, to use the MediaStream
                APIs, in reality this turned out to be way slower performance wise, often taking as much as more than
                double the time in extracting a frame compared to directly drawing the video element in a Offscreen
                canvas’ 2D context and extracting out the image bitmap from it :(
            </p>
        </div>
    </body>
</html>
